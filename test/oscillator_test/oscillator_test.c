/**
 * This outputs a pattern generated by oscillator.c to a numpy file so that it can be easily
 * graphed by matplotlib.
 */

#include "oscillator.h"

#include <stdint.h>
#include <stdio.h>
#include <string.h>

void write_doubles_to_numpy_file(const char* name, double* data, int len)
{
    FILE* f = fopen(name, "wb");

    int header_bytes_so_far = 0;

    const uint8_t magic_header[] = {
	0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00, 0x76, 0x00
    };
    header_bytes_so_far += fwrite(magic_header, 1, sizeof(magic_header), f);


    const int FORMAT_LEN = 96;
    char format[FORMAT_LEN];
    snprintf(format, FORMAT_LEN,
	     "{'descr': '<f8', 'fortran_order': False, 'shape': (%i,), }", len);
    header_bytes_so_far += fwrite(format, 1, strlen(format), f);

    while (header_bytes_so_far < 127) {
	header_bytes_so_far += fwrite(" ", 1, 1, f);
    }
    header_bytes_so_far += fwrite("\x0a", 1, 1, f);

    int res = fwrite(data, sizeof(*data), len, f);
    printf("wrote %i/%i doubles to %s\n", res, len, name);

    fclose(f);
}


int main(int argc, char** argv)
{
    if (argc != 2) {
	printf("usage: %s <output npy name>\n", argv[0]);
	return 1;
    }

    oscillator_setup_tables();

    double blip_table_double[NUM_PHASES][SAMPLES_PER_SINC];
    for (int i = 0; i < NUM_PHASES; i++)
	for (int j = 0; j < SAMPLES_PER_SINC; j++)
	    blip_table_double[i][j] = ((double)blip_table_q_15[i][j] / ((double)(1 << 15)));

    oscillator_t osc;
    oscillator_initialize(&osc, 48000);
    oscillator_set_frequency(&osc, (int32_t)((440.0 * (1 << 16)) + 0.5));
    osc.type = OSCILLATOR_TYPE_SQUARE;

    const int SAMPLES_TO_RENDER = (1 << 14);
    double output_audio[SAMPLES_TO_RENDER];
    const int32_t SAMPLES_PER_BUFFER = 128;
    for (int i = 0; i < (SAMPLES_TO_RENDER / SAMPLES_PER_BUFFER); i++) {
	int32_t buffer[SAMPLES_PER_BUFFER];
	oscillator_render_to_buffer(&osc, buffer, SAMPLES_PER_BUFFER);

	for (int j = 0; j < SAMPLES_PER_BUFFER; j++) {
	    output_audio[(i * SAMPLES_PER_BUFFER) + j] = ((double)buffer[j]) / ((double)(1 << 29));
	}
    }

    //write_doubles_to_numpy_file(argv[1], &blip_table_double[0][0],
    //SAMPLES_PER_SINC * NUM_PHASES);

    write_doubles_to_numpy_file(argv[1], output_audio, SAMPLES_TO_RENDER);

    return 0;
}
